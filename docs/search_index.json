[
["index.html", "Using GIS for invasive species research 1 Overview 1.1 Project objectives 1.2 Get started…", " Using GIS for invasive species research Anthony Davidson 2019-09-06 1 Overview &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD This respository contains a collection of dynamic programming tools and introductory tutorials for dealing with maps and geo-spatical analysis using rmarkdown and shiny. ======= This respository contains a collection of dynamic programming tools and introductory tutorials for GIS in R. &gt;&gt;&gt;&gt;&gt;&gt;&gt; jekyll-testing 1.1 Project objectives The overall objective is to create a landing page and collection of GIS work in R. All the examples will focus on invasive species dynamics for now but will extend to other areas of ecology and research. The current set of goals for this project also meet the requirements needed to produce the figures for my personal reproducible phd research. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ### Objective one Produce static-maps for the first publication of my PhD. Draft here Davidson2019a 1.1.0.1 Datasets Grid locations are in a kmz file called “invasive-species-location-research.kmz” here kml file still called “invasive-species-location-research.kmz” currently Outline of NZ here \"\" here Forest vegetation here \"\" here 1.1.0.1 Data from landCare 2019 publication here \"\" here 1.1.0.1 Objective One Produce static maps for the first publication of my PhD. Draft here - Davidson2019a Datasets Beech forest dataset jekyll-testing Grid locations are can be downloaded as a kmz or kml file. This is currently labedl “invasive-species-location-research.kml” here NZ basic map examples are here under resources chapter NZ Forest vegetation data comes from … and saved as \"\" here 1.1.1 Objective Two Produce static maps for the following data-set [Davidson2019b] [same as above] 1.1.2 Objective Three Produce static maps for the following data-set [Davidson2019c] [same as above] 1.2 Get started… Fork this repo here Pull project into Rstudio using version control. 1567561101782 Ensure that your local RStudio packages are up to date. For more details this following the same contributing options as the website instructions here. Note This book is built from the absolute minimum you need to start a bookdown book. You can find the preview of the unmodified template of the book at http://seankross.com/bookdown-start/ All of the content of this repository is licensed CC0. The content of the mapping/GIS was orginally forked from from the following github repositories: Creating maps in R: A textbook on geocomputational analysis in R 1.2.1 Packages To run this book in RStudio the following packages are needed. tidyverse MapView: a 3D interactive R packages Video library(spData) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(sf) ## Linking to GEOS 3.6.1, GDAL 2.2.3, PROJ 4.9.3 library(bookdown) library(leaflet) library(leaflet.extras) library(geojsonio) ## Registered S3 method overwritten by &#39;geojsonio&#39;: ## method from ## print.location dplyr ## ## Attaching package: &#39;geojsonio&#39; ## The following object is masked from &#39;package:base&#39;: ## ## pretty "],
["intro.html", " 2 Introduction 2.1 Data", " 2 Introduction Creating maps using spatial data in R GIS is an area of R coding I have kept away from hoping that I would work it out at a later date. Sadly, it has got to the point where I want to be able to build more complex maps in shiny applications towards the end of my PhD and need to create a base of code to go from. Luckily, the text book “Spatial Analysis in R” has just come out in its second edition and is available in as a bookdown repository including the full text here. This page is a outline of the current resources I am working on and using for my publication and website maps. I have begun by using my normal reproducible workflow and file structure. EXAMPLE You can use things like addWMSTiles() to add WMS (Web Map Service) tiles. The map below shows the Base Reflectivity (a measure of the intensity of precipitation occurring) using the WMS from the Iowa Environmental Mesonet: leaflet() %&gt;% addTiles() %&gt;% setView(-93.65, 42.0285, zoom = 4) %&gt;% addWMSTiles( &quot;http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi&quot;, layers = &quot;nexrad-n0r-900913&quot;, options = WMSTileOptions(format = &quot;image/png&quot;, transparent = TRUE), attribution = &quot;Weather data © 2012 IEM Nexrad&quot; ) 2.0.1 NZ layers # Add fill layer to nz shape tm_shape(nz) + tm_fill() # Add border layer to nz shape tm_shape(nz) + tm_borders() # Add fill and border layers to nz shape tm_shape(nz) + tm_fill() + tm_borders() 2.0.1.1 Attributes qtm() is a handy function to create quick thematic maps (hence the snappy name). It is concise and provides a good default visualization in many cases: qtm(nz), for example, is equivalent to tm_shape(nz) + tm_fill() + tm_borders(). Further, layers can be added concisely using multiple qtm() calls, such as qtm(nz) + qtm(nz_height). The disadvantage is that it makes aesthetics of individual layers harder to control, explaining why we avoid teaching it in this chapter. map_nz = tm_shape(nz) + tm_polygons() class(map_nz) ## [1] &quot;tmap&quot; #&gt; [1] &quot;tmap&quot; nz_water = st_union(nz) %&gt;% st_buffer(22200) %&gt;% st_cast(to = &quot;LINESTRING&quot;) g = st_graticule(nz, lon = c(170, 175), lat = c(-45, -40, -35)) plot(nz_water, graticule = g, axes = TRUE, col = &quot;blue&quot;) # raster::plot(nz_elev / 1000, add = TRUE) # map_nz1 = map_nz + # tm_shape(nz_elev) + tm_raster(alpha = 0.7) plot(st_geometry(nz), add = TRUE) # map_nz2 = map_nz1 + # tm_shape(nz_water) + tm_lines() # map_nz3 = map_nz2 + # tm_shape(nz_height) + tm_dots() # tmap_arrange(map_nz1, map_nz2, map_nz3) 2.0.1.2 Asthetics ma1 = tm_shape(nz) + tm_fill(col = &quot;red&quot;) ma2 = tm_shape(nz) + tm_fill(col = &quot;red&quot;, alpha = 0.3) ma3 = tm_shape(nz) + tm_borders(col = &quot;blue&quot;) ma4 = tm_shape(nz) + tm_borders(lwd = 3) ma5 = tm_shape(nz) + tm_borders(lty = 2) ma6 = tm_shape(nz) + tm_fill(col = &quot;red&quot;, alpha = 0.3) + tm_borders(col = &quot;blue&quot;, lwd = 3, lty = 2) tmap_arrange(ma1, ma2, ma3, ma4, ma5, ma6) This page is a outline of the current resources I am working on and using for my publication and website maps. I have begun by using my normal reproducible workflow and file structure. The full set of resources is currently on a private repository. 2.1 Data {: .box-note} Note: This can currently me modified and changed by anyone with the link. As it comes more important for the dataset to not be modified by others we will tighten this process up using the leaflet and shiny app process we are using for the mapping and analysis at the bottom of this post. "],
["divingin.html", " 3 Diving In 3.1 Downloading 3.2 kml to tidy dataset", " 3 Diving In There are plenty of github repositories explaining the different types of GIS and using R. Below is the public google-my-maps map that can be modified an worked on from within the window provided below. {: .box-note} Note: This can currently me modified and changed by anyone with the link. As it comes more important for the dataset to not be modified by others we will tighten this process up using the leaflet and shiny app process we are using for the mapping and analysis at the bottom of this post. So far we have saved a leaflet rmd file as an html file and pasted it from the includes folder of the website. We will tighten this up too. :) 3.1 Downloading To begin with check this is working in your local RStudio enviroment Install the required packages. You need a recent version of the GDAL, GEOS, Proj.4, and UDUNITS libraries installed for this to work on Mac and Linux. More information on that at https://github.com/r-spatial/sf#installling. # devtools::install_github(&quot;robinlovelace/geocompr&quot;) Load the ones we need: In addition, it uses the following visualization packages: library(tmap) # for static and interactive maps library(leaflet) # for interactive maps library(mapview) # for interactive maps library(ggplot2) # tidyverse data visualization package library(shiny) # for web applications Check it’s all working, e.g. with this command: world %&gt;% plot() And some blogging on the matter here. There are plenty of github repositories explaining the different types of GIS and using R. Below is the public google-my-maps map that can be modified an worked on from within the window provided below. 3.2 kml to tidy dataset Import data from downloaded kml file from the my-maps data. Download the kml file from online (NOT the kmz file) {.:Note} A KMZ file is just a zipped KML file, possibly with associated embedded images, icons, etc. So any program that supports KMZ files internally unzips them to access their KML files. That may be a reason why many open source programs do not bother supporting KMZ once KML support is implemented: you just need to use an additional unzipping library of your choice, to convert the KMZ to KML. The linked posts give some JavaScript-based solutions for unzipping. source(&quot;./R/kml_to_tidy.R&quot;) ## -- Attaching packages ----------------------------------------------- tidyverse 1.2.1 -- ## v tibble 2.1.3 v purrr 0.3.2 ## v tidyr 0.8.3 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.4.0 ## -- Conflicts -------------------------------------------------- tidyverse_conflicts() -- ## x tidyr::extract() masks raster::extract() ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() ## x raster::select() masks dplyr::select() ## Multiple layers are present in data source C:\\Code\\Creating-maps-in-R\\data\\invasive-species-NAH-research.kml, reading layer `Hollyford&#39;. ## Use `st_layers&#39; to list all layer names and their type in a data source. ## Set the `layer&#39; argument in `st_read&#39; to read a particular layer. ## Warning in evalq((function (..., call. = TRUE, immediate. = FALSE, ## noBreaks. = FALSE, : automatically selected the first layer in a data ## source containing more than one. ## Reading layer `Hollyford&#39; from data source `C:\\Code\\Creating-maps-in-R\\data\\invasive-species-NAH-research.kml&#39; using driver `KML&#39; ## Simple feature collection with 10 features and 2 fields ## geometry type: GEOMETRY ## dimension: XYZ ## bbox: xmin: 167.9963 ymin: -45.06019 xmax: 168.1392 ymax: -44.70935 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## Observations: 10 ## Variables: 3 ## $ Name &lt;fct&gt; Gunns Camp, Choqenout and Ruscoe 2000, Hollyford V... ## $ Description &lt;fct&gt; &quot;&quot;, &quot;Eglinton Valley&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,... ## $ geometry &lt;GEOMETRY [°]&gt; POINT Z (168.1392 -44.76039 0), POINT Z (... tidy.kat ## # A tibble: 12 x 7 ## folder name description styleUrl longitude latitude altitude ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hollyford Gunns Camp &lt;NA&gt; #icon-1899~ 168. -44.8 0 ## 2 Hollyford Choqenout~ Eglinton V~ #icon-1899~ 168. -45.1 0 ## 3 Hollyford Hollyford~ &lt;NA&gt; #icon-1899~ 168. -44.8 0 ## 4 Hollyford Hollyford~ &lt;NA&gt; #icon-1899~ 168. -44.7 0 ## 5 Hollyford Point 9 &lt;NA&gt; #icon-1899~ 168. -44.8 0 ## 6 Hollyford Point 10 x = 10, y ~ #icon-1899~ 168. -44.9 0 ## 7 Eglinton~ MR1 &lt;NA&gt; #icon-1899~ 168. -44.9 0 ## 8 Eglinton~ M1 &lt;NA&gt; #icon-1899~ 168. -44.9 0 ## 9 Eglinton~ M1 &lt;NA&gt; #icon-1899~ 168. -44.9 0 ## 10 Eglinton~ R1 &lt;NA&gt; #icon-1899~ 168. -44.9 0 ## 11 Eglinton~ MR1 &lt;NA&gt; #icon-1899~ 168. -44.9 0 ## 12 Eglinton~ R1 &lt;NA&gt; #icon-1899~ 168. -44.9 0 3.2.1 Save Save csv data for arcGIS work from here as: write.csv(tidy.kat, &quot;./data/kml_tidy_data.csv&quot;) "],
["wnp.html", " 4 Work in progress 4.1 My notes 4.2 Building maps for manuscripts", " 4 Work in progress library(tidyverse) ## -- Attaching packages ----------------------------------------------- tidyverse 1.2.1 -- ## v ggplot2 3.2.1 v purrr 0.3.2 ## v tibble 2.1.3 v dplyr 0.8.3 ## v tidyr 0.8.3 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.4.0 ## -- Conflicts -------------------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() As I work through the steps I will add code and notes to this section of the gitbook. The first step I have done is to convert the downloaded my-maps data. To conbvert a my-maps online map into a tidy format we can work in I have done the following. 4.0.1 Static maps Static maps are the most common type of visual output from geocomputation. Standard formats include .png and .pdf for raster and vector outputs respectively. Initially, static maps were the only type of maps that R could produce. Things advanced with the release of sp (see Pebesma and Bivand 2005) and many techniques for map making have been developed since then. However, despite the innovation of interactive mapping, static plotting was still the emphasis of geographic data visualisation in R a decade later (Cheshire and Lovelace 2015). The generic plot() function is often the fastest way to create static maps from vector and raster spatial objects (see sections 2.2.3 and 2.3.2). Sometimes, simplicity and speed are priorities, especially during the development phase of a project, and this is where plot() excels. The base R approach is also extensible, with plot() offering dozens of arguments. Another approach is the grid package which allows low level control of static maps, as illustrated in Chapter 14 of Murrell (2016). This section focuses on tmap and emphasizes the important aesthetic and layout options. tmap is a powerful and flexible map-making package with sensible defaults. It has a concise syntax that allows for the creation of attractive maps with minimal code which will be familiar to ggplot2 users. It also has the unique capability to generate static and interactive maps using the same code via tmap_mode(). Finally, it accepts a wider range of spatial classes (including raster objects) than alternatives such as ggplot2 (see the vignettes tmap-getstarted and tmap-changes-v2, as well as Tennekes (2018), for further documentation). Download the kmz file from online. A KMZ file is just a zipped KML file, possibly with associated embedded images, icons, etc. So any program that supports KMZ files internally unzips them to access their KML files. That may be a reason why many open source programs do not bother supporting KMZ once KML support is implemented: you just need to use an additional unzipping library of your choice, to convert the KMZ to KML. The linked posts give some JavaScript-based solutions for unzipping. dat.loc &lt;- c(&quot;C://Code/Creating-maps-in-R/data/invasive-species-location-research.kmz&quot;) # kml.dat &lt;- xml2::download_xml zipF&lt;- &quot;C://Code/Creating-maps-in-R/data/invasive-species-location-research.kmz&quot; outDir &lt;- &quot;C://Code/Creating-maps-in-R/data/unzipped-files/&quot; # unzip(zipF,exdir=&quot;C://Code/Creating-maps-in-R/data/unzipped-files/&quot;) # unzip(zipfile = &quot;C://Code/Creating-maps-in-R/data/Canberra-transit/images/invasive-species-location-research.kmz&quot;) # xml.locations &lt;- XML::xmlToDataFrame(&quot;./doc.kml&quot;) exdir defines the directory to extract files to. It will be created if not already available. If you don’t set exdir, unzip will just unzip it to your current working directory. # glimpse(xml.locations) # str(xml.locations) # install dev version of ggmap # devtools::install_github(&quot;dkahle/ggmap&quot;) library(ggmap) ## Google&#39;s Terms of Service: https://cloud.google.com/maps-platform/terms/. ## Please cite ggmap if you use it! See citation(&quot;ggmap&quot;) for details. #&gt; Loading required package: ggplot2 #&gt; Google Maps API Terms of Service: http://developers.google.com/maps/terms. #&gt; Please cite ggmap if you use it: see citation(&quot;ggmap&quot;) for details. # # save api key # register_google(key = &quot;YOUR_API_KEY&quot;) # # # check if key is saved # has_goog_key() # #&gt; [1] TRUE # # ggmap( # ggmap = get_map( # &quot;Dayton&quot;, # zoom = 13, scale = &quot;auto&quot;, # maptype = &quot;satellite&quot;, # source = &quot;google&quot;), # extent = &quot;device&quot;, # legend = &quot;topright&quot; # ) #&gt; Source : https://maps.googleapis.com/maps/api/staticmap?center=Dayton&amp;zoom=13&amp;size=640x640&amp;scale=2&amp;maptype=satellite&amp;language=en-EN&amp;key=AIzaSyBmXB5S5_NIqo6lAGH-_U-TbhrQjhOsplU #&gt; Source : https://maps.googleapis.com/maps/api/geocode/json?address=Dayton&amp;key=AIzaSyBmXB5S5_NIqo6lAGH-_U-TbhrQjhOsplU 4.1 My notes These resources are very basic but they may be helpful for me later. Found in stack comments here library(tidyverse) library(kableExtra) ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows source(&quot;./R/kml_to_tidy.R&quot;) ## Linking to GEOS 3.6.1, GDAL 2.2.3, PROJ 4.9.3 ## Registered S3 method overwritten by &#39;geojsonio&#39;: ## method from ## print.location dplyr ## ## Attaching package: &#39;geojsonio&#39; ## The following object is masked from &#39;package:base&#39;: ## ## pretty ## Multiple layers are present in data source C:\\Code\\Creating-maps-in-R\\data\\invasive-species-NAH-research.kml, reading layer `Hollyford&#39;. ## Use `st_layers&#39; to list all layer names and their type in a data source. ## Set the `layer&#39; argument in `st_read&#39; to read a particular layer. ## Warning in evalq((function (..., call. = TRUE, immediate. = FALSE, ## noBreaks. = FALSE, : automatically selected the first layer in a data ## source containing more than one. ## Reading layer `Hollyford&#39; from data source `C:\\Code\\Creating-maps-in-R\\data\\invasive-species-NAH-research.kml&#39; using driver `KML&#39; ## Simple feature collection with 10 features and 2 fields ## geometry type: GEOMETRY ## dimension: XYZ ## bbox: xmin: 167.9963 ymin: -45.06019 xmax: 168.1392 ymax: -44.70935 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## Observations: 10 ## Variables: 3 ## $ Name &lt;fct&gt; Gunns Camp, Choqenout and Ruscoe 2000, Hollyford V... ## $ Description &lt;fct&gt; &quot;&quot;, &quot;Eglinton Valley&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,... ## $ geometry &lt;GEOMETRY [°]&gt; POINT Z (168.1392 -44.76039 0), POINT Z (... kable(tidy.kat, format = &quot;markdown&quot;) folder name description styleUrl longitude latitude altitude Hollyford Gunns Camp NA #icon-1899-0288D1-nodesc 168.1392 -44.76039 0 Hollyford Choqenout and Ruscoe 2000 Eglinton Valley #icon-1899-0288D1 167.9963 -45.06019 0 Hollyford Hollyford Valley Lookout NA #icon-1899-0288D1-nodesc 168.1050 -44.80905 0 Hollyford Hollyford Airstrip NA #icon-1899-0288D1-nodesc 168.1337 -44.73744 0 Hollyford Point 9 NA #icon-1899-0288D1-nodesc 168.1262 -44.79766 0 Hollyford Point 10 x = 10, y = 250 #icon-1899-0288D1 168.0794 -44.90247 0 Eglinton Valley MR1 NA #icon-1899-F9A825-nodesc 168.0776 -44.89081 0 Eglinton Valley M1 NA #icon-1899-FBC02D-nodesc 168.1005 -44.85371 0 Eglinton Valley M1 NA #icon-1899-FBC02D-nodesc 168.0748 -44.89257 0 Eglinton Valley R1 NA #icon-1899-000000-nodesc 168.0968 -44.85569 0 Eglinton Valley MR1 NA #icon-1899-FBC02D-nodesc 168.0995 -44.85768 0 Eglinton Valley R1 NA #icon-1899-000000-nodesc 168.0789 -44.89277 0 4.2 Building maps for manuscripts These starting resources have come from chapter-8 of the geocomp book. To make this quick I have used the rmarkdown function render to create a r file that can then be sourced here for building my data specific maps. # rmarkdown::render(&quot;./03-Work-In-Progress.Rmd&quot;) # knitr::purl(&quot;./03-Work-In-Progress.Rmd&quot;, &quot;./R/03-Work-In-Progress.R&quot;, documentation = 2) source(&quot;./R/03-Work-In-Progress.R&quot;, echo = FALSE) ## Legend labels were too wide. The labels have been resized to 0.29, 0.29, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.29, 0.29, 0.29, 0.29, 0.29, 0.29, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.29, 0.29, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.47, 0.47, 0.47, 0.47, 0.47, 0.47. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.47, 0.47, 0.47, 0.47, 0.47. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.47, 0.47, 0.47, 0.47, 0.47. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.47, 0.47, 0.47, 0.47, 0.47. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## Legend labels were too wide. The labels have been resized to 0.44, 0.29, 0.29, 0.29, 0.29. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. glimpse(nz) ## Observations: 16 ## Variables: 7 ## $ Name &lt;chr&gt; &quot;Northland&quot;, &quot;Auckland&quot;, &quot;Waikato&quot;, &quot;Bay of Plen... ## $ Island &lt;chr&gt; &quot;North&quot;, &quot;North&quot;, &quot;North&quot;, &quot;North&quot;, &quot;North&quot;, &quot;No... ## $ Land_area &lt;dbl&gt; 12500.5611, 4941.5726, 23900.0364, 12071.1447, 8... ## $ Population &lt;dbl&gt; 175500, 1657200, 460100, 299900, 48500, 164000, ... ## $ Median_income &lt;int&gt; 23400, 29600, 27900, 26200, 24400, 26100, 29100,... ## $ Sex_ratio &lt;dbl&gt; 0.9424532, 0.9442858, 0.9520500, 0.9280391, 0.93... ## $ geom &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((1745493 600..., MUL... 4.2.1 First tmap attempt ma1 = tm_shape(nz) + tm_fill(col = &quot;red&quot;) ma2 = tm_shape(nz) + tm_fill(col = &quot;red&quot;, alpha = 0.3) ma3 = tm_shape(nz) + tm_borders(col = &quot;blue&quot;) ma4 = tm_shape(nz) + tm_borders(lwd = 3) ma5 = tm_shape(nz) + tm_borders(lty = 2) ma6 = tm_shape(nz) + tm_fill(col = &quot;red&quot;, alpha = 0.3) + tm_borders(col = &quot;blue&quot;, lwd = 3, lty = 2) tmap_arrange(ma1, ma2, ma3, ma4, ma5, ma6) 4.2.1.1 Grey background tm_shape(nz) + tm_fill(col = &quot;black&quot;, alpha = 0.3) 4.2.1.2 Boarders tm_shape(nz) + tm_fill(col = &quot;black&quot;, alpha = 0.3) + tm_borders(col = &quot;blue&quot;) 4.2.1.3 Title and legend legend_title &lt;- expression(&quot;Area (km&quot;^2*&quot;)&quot;) tm_shape(nz) + tm_fill(col = &quot;black&quot;, alpha = 0.3) + tm_borders(col = &quot;blue&quot;) + tm_shape(nz) + tm_fill(col = &quot;Land_area&quot;, title = legend_title) + tm_borders() 4.2.1.4 North arrow tm_shape(nz) + tm_fill(col = &quot;black&quot;, alpha = 0.3) + tm_borders(col = &quot;blue&quot;) + tm_compass(type = &quot;8star&quot;, position = c(&quot;left&quot;, &quot;top&quot;)) 4.2.1.5 Scale tm_shape(nz) + tm_fill(col = &quot;black&quot;, alpha = 0.3) + tm_borders(col = &quot;blue&quot;) + tm_compass(type = &quot;8star&quot;, position = c(&quot;left&quot;, &quot;top&quot;)) + tm_scale_bar(breaks = c(0, 100, 200), text.size = 1) 4.2.1.6 Black and white tm_shape(nz) + tm_fill(col = &quot;black&quot;, alpha = 0.3) + tm_borders(lty = 2) library(leaflet) library(leaflet.extras) "],
["outputs.html", " 5 Outputs 5.1 My Notes", " 5 Outputs Using and applying GIS techniques in R has become much easier since the additional functionality of Java-script libraries. One of these libraries in the leaflet library for mapping. Below are some examples of these mapping tools with examples. I like the idea of know what to do in arcGIS so that it is easy to work with researchers that use either R or arcGIS. For a GIS map there are two main options. Here are the resources for building interactive and static maps in R using a range of different packages: ’leaflet` 5.0.1 A single location on a map Here is the birthplace of R plotted with leaflet, addTiles and the addMarkers… 5.0.2 Leaflet plot options still coming 5.1 My Notes I have sent the following to Matt to input into arcGIS and compare rendered maps. # grid.locations &lt;- # label add hand drawn image here 5.1.1 Extracting mymaps data This is for security reasons. library(leaflet) library(leaflet.extras) "],
["resources.html", " 6 Resources 6.1 A single location on a map 6.2 Leaflet plots 6.3 My Notes 6.4 Downloading 6.5 Using Basemaps 6.6 Choropleths 6.7 Introduction 6.8 Static maps 6.9 Animated maps 6.10 Interactive maps 6.11 Mapping applications 6.12 Other mapping packages 6.13 Exercises 6.14 My Notes 6.15 A single location on a map 6.16 Leaflet plots 6.17 My Notes", " 6 Resources 6.1 A single location on a map Here is the birthplace of R plotted with leaflet, addTiles and the addMarkers… 6.2 Leaflet plots still coming 6.3 My Notes I have sent the following colleagues to input into arcGIS and compare rendered maps/workflow issues with reproducibililty. [coming below] Vignettes Creating maps in R “www.ssnhub.com/creating-maps-in-r.html” Map for Chapter 2: Beech forests \"\" Examples LandCare 2019 publication here \"\" Data from landCare 2019 publication here \"\" here Rcode My attempt so far \"\" here GIS cheat \"\" here Powerpoint cheat \"\" here Static maps NZ beech forest dynamics \"\" here 8 grids full data \"\" here only 6 used \"\" here South Island of NZ \"\" here library(leaflet) library(leaflet.extras) &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD # Resources {#resource} ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; jekyll-testing There are plenty of github repositories explaining the different types of GIS and using R. Below is the public google-my-maps map that can be modified an worked on from within the window provided below. {: .box-note} Note: This can currently me modified and changed by anyone with the link. As it comes more important for the dataset to not be modified by others we will tighten this process up using the leaflet and shiny app process we are using for the mapping and analysis at the bottom of this post. So far we have saved a leaflet rmd file as an html file and pasted it from the includes folder of the website. We will tighten this up too. :) 6.4 Downloading To begin with check this is working in your local RStudio enviroment Install the required packages. You need a recent version of the GDAL, GEOS, Proj.4, and UDUNITS libraries installed for this to work on Mac and Linux. More information on that at https://github.com/r-spatial/sf#installling. # devtools::install_github(&quot;robinlovelace/geocompr&quot;) Load the ones we need: In addition, it uses the following visualization packages: library(tmap) # for static and interactive maps library(leaflet) # for interactive maps library(mapview) # for interactive maps library(ggplot2) # tidyverse data visualization package library(shiny) # for web applications library(spData) library(dplyr) library(sf) library(bookdown) library(leaflet) library(leaflet.extras) library(geojsonio) library(sf) library(raster) library(dplyr) library(spData) # library(spDataLarge) Check it’s all working, e.g. with this command: world %&gt;% plot() And some blogging on the matter here. 6.4.0.1 Content below from leaflet github account 6.5 Using Basemaps Leaflet supports basemaps using map tiles, popularized by Google Maps and now used by nearly all interactive web maps. 6.5.1 Default (OpenStreetMap) Tiles The easiest way to add tiles is by calling addTiles() with no arguments; by default, OpenStreetMap tiles are used. m &lt;- leaflet() %&gt;% setView(lng = -71.0589, lat = 42.3601, zoom = 12) m %&gt;% addTiles() 6.5.2 Third-Party Tiles Alternatively, many popular free third-party basemaps can be added using the addProviderTiles() function, which is implemented using the leaflet-providers plugin. See here for the complete set. As a convenience, leaflet also provides a named list of all the third-party tile providers that are supported by the plugin. This enables you to use auto-completion feature of your favorite R IDE (like RStudio) and not have to remember or look up supported tile providers; just type providers$ and choose from one of the options. You can also use names(providers) to view all of the options. m %&gt;% addProviderTiles(providers$Stamen.Toner) m %&gt;% addProviderTiles(providers$CartoDB.Positron) m %&gt;% addProviderTiles(providers$Esri.NatGeoWorldMap) Note that some tile set providers require you to register; see the project page for more information. You can pass access tokens/keys, and other options, to the tile provider by populating the options argument with the providerTileOptions() function. 6.5.3 Custom Tile URL Template If you happen to have a custom map tile URL template to use, you can provide it as an argument to addTiles(). 6.5.4 WMS Tiles You can use addWMSTiles() to add WMS (Web Map Service) tiles. The map below shows the Base Reflectivity (a measure of the intensity of precipitation occurring) using the WMS from the Iowa Environmental Mesonet: leaflet() %&gt;% addTiles() %&gt;% setView(-93.65, 42.0285, zoom = 4) %&gt;% addWMSTiles( &quot;http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi&quot;, layers = &quot;nexrad-n0r-900913&quot;, options = WMSTileOptions(format = &quot;image/png&quot;, transparent = TRUE), attribution = &quot;Weather data © 2012 IEM Nexrad&quot; ) 6.5.5 Combining Tile Layers You aren’t restricted to using a single basemap on a map; you can stack them by adding multiple tile layers. This generally only makes sense if the front tiles consist of semi transparent tiles, or have an adjusted opacity via the options argument. m %&gt;% addProviderTiles(providers$MtbMap) %&gt;% addProviderTiles(providers$Stamen.TonerLines, options = providerTileOptions(opacity = 0.35)) %&gt;% addProviderTiles(providers$Stamen.TonerLabels) 6.6 Choropleths Making choropleths with leaflet is easy. In this example, we’ll duplicate the step-by-step choropleth tutorial from the Leaflet.js website. The final result will look like this (scroll to the end to see the completed code): ## [1] &quot;SpatialPolygonsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; 6.6.1 Data source We’ll start by loading the data from JSON. While the Leaflet.js example loads the JSON directly into JavaScript, with the Leaflet R package we instead want to load the data into R. In this case, we’ll use the geojsonio package to load the data into sp objects, which will let us easily manipulate the geographic features, and their properties, in R. # states &lt;- geojsonio::geojson_read(&quot;json/us-states.geojson&quot;, what = &quot;sp&quot;) class(states) ## [1] &quot;SpatialPolygonsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; names(states) ## [1] &quot;id&quot; &quot;name&quot; &quot;density&quot; As you can see, we now have a SpatialPolygonsDataFrame with name (state name) and density (population density in people/mi2) columns from the GeoJSON. 6.6.2 Basic states map Next, let’s make a basic map with just the outline of the states. For our basemap, we’ll use the same \"mapbox.light\" MapBox style that the example does; if you don’t have a MapBox account, you can just use addTiles() in place of the addProviderTiles call, or choose a free provider. m &lt;- leaflet(states) %&gt;% setView(-96, 37.8, 4) %&gt;% addProviderTiles(&quot;MapBox&quot;, options = providerTileOptions( id = &quot;mapbox.light&quot;, accessToken = Sys.getenv(&#39;MAPBOX_ACCESS_TOKEN&#39;))) We’ve saved the basic basemap as a separate variable m so we can easily iterate on the addPolygons call as we work through the rest of the tutorial. To add uniform polygons with default styling, just call addPolygons with no additional arguments. m %&gt;% addPolygons() 6.6.3 Adding some color Now, let’s color the states according to their population density. You have various options for mapping data to colors; for this example we’ll match the Leaflet.js tutorial by mapping a specific set of bins into RColorBrewer colors. First, we’ll define the bins. This is a numeric vector that defines the boundaries between intervals ((0,10], (10,20], and so on). Then, we’ll call colorBin to generate a palette function that maps the RColorBrewer \"YlOrRd\" colors to our bins. Finally, we’ll modify addPolygons to use the palette function and the density values to generate a vector of colors for fillColor, and also add some other static style properties. bins &lt;- c(0, 10, 20, 50, 100, 200, 500, 1000, Inf) pal &lt;- colorBin(&quot;YlOrRd&quot;, domain = states$density, bins = bins) m %&gt;% addPolygons( fillColor = ~pal(density), weight = 2, opacity = 1, color = &quot;white&quot;, dashArray = &quot;3&quot;, fillOpacity = 0.7) 6.6.4 Adding interaction The next thing we’ll want is to make the polygons highlight as the mouse passes over them. The addPolygon function has a highlight argument that makes this simple. m %&gt;% addPolygons( fillColor = ~pal(density), weight = 2, opacity = 1, color = &quot;white&quot;, dashArray = &quot;3&quot;, fillOpacity = 0.7, highlight = highlightOptions( weight = 5, color = &quot;#666&quot;, dashArray = &quot;&quot;, fillOpacity = 0.7, bringToFront = TRUE)) (The Leaflet.js tutorial also adds an event handler that zooms into a state when it’s clicked. This isn’t currently possible with the Leaflet R package, except with either custom JavaScript or using Shiny, both of which are outside the scope of this example.) 6.6.5 Custom info Now let’s expose the state names and values to the user. The Leaflet.js tutorial shows the hovered-over state’s information in a custom control. Again, that’s possible by adding custom JavaScript or using Shiny, but for this example we’ll use the built-in labels feature instead. We’ll generate the labels by handcrafting some HTML, and passing it to lapply(htmltools::HTML) so that Leaflet knows to treat each label as HTML instead of as plain text. We’ll also set some label options to improve the style of the label element itself. labels &lt;- sprintf( &quot;&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g people / mi&lt;sup&gt;2&lt;/sup&gt;&quot;, states$name, states$density ) %&gt;% lapply(htmltools::HTML) m &lt;- m %&gt;% addPolygons( fillColor = ~pal(density), weight = 2, opacity = 1, color = &quot;white&quot;, dashArray = &quot;3&quot;, fillOpacity = 0.7, highlight = highlightOptions( weight = 5, color = &quot;#666&quot;, dashArray = &quot;&quot;, fillOpacity = 0.7, bringToFront = TRUE), label = labels, labelOptions = labelOptions( style = list(&quot;font-weight&quot; = &quot;normal&quot;, padding = &quot;3px 8px&quot;), textsize = &quot;15px&quot;, direction = &quot;auto&quot;)) m This is the final version of our polygon layer, so let’s save the result back to the m variable. 6.6.6 Legend As our final step, let’s add a legend. Because we chose to color our map using colorBin, the addLegend function makes it particularly easy to add a legend with the correct colors and intervals. m %&gt;% addLegend(pal = pal, values = ~density, opacity = 0.7, title = NULL, position = &quot;bottomright&quot;) This chapter requires the following packages that we have already been using: 6.7 Introduction A satisfying and important aspect of geographic research is communicating the results. Map making — the art of cartography — is an ancient skill that involves communication, intuition, and an element of creativity. Static mapping is straightforward with plot(), as we saw in Section ??. It is possible to create advanced maps using base R methods (???), but this chapter focuses on dedicated map-making packages. When learning a new skill, it makes sense to gain depth-of-knowledge in one area before branching out. Map making is no exception, hence this chapter’s coverage of one package (tmap) in depth rather than many superficially. In addition to being fun and creative, cartography also has important practical applications. A carefully crafted map is vital for effectively communicating the results of your work (???): Amateur-looking maps can undermine your audience’s ability to understand important information and weaken the presentation of a professional data investigation. Maps have been used for several thousand years for a wide variety of purposes. Historic examples include maps of buildings and land ownership in the Old Babylonian dynasty more than 3000 years ago and Ptolemy’s world map in his masterpiece Geography nearly 2000 years ago (???). Map making has historically been an activity undertaken only by, or on behalf of, the elite. This has changed with the emergence of open source mapping software such as the R package tmap and the ‘print composer’ in QGIS which enable anyone to make high-quality maps, enabling ‘citizen science’. Maps are also often the best way to present the findings of geocomputational research in a way that is accessible. Map making is therefore a critical part of geocomputation and its emphasis not only on describing, but also changing the world. This chapter shows how to make a wide range of maps. The next section covers a range of static maps, including aesthetic considerations, facets and inset maps. Sections 6.9 to 6.11 cover animated and interactive maps (including web maps and mapping applications). Finally, Section 6.12 covers a range of alternative map-making packages including ggplot2 and cartogram. 6.8 Static maps Static maps are the most common type of visual output from geocomputation. Standard formats include .png and .pdf for raster and vector outputs respectively. Initially, static maps were the only type of maps that R could produce. Things advanced with the release of sp (see ???) and many techniques for map making have been developed since then. However, despite the innovation of interactive mapping, static plotting was still the emphasis of geographic data visualisation in R a decade later (???). The generic plot() function is often the fastest way to create static maps from vector and raster spatial objects (see sections ?? and ??). Sometimes, simplicity and speed are priorities, especially during the development phase of a project, and this is where plot() excels. The base R approach is also extensible, with plot() offering dozens of arguments. Another approach is the grid package which allows low level control of static maps, as illustrated in Chapter 14 of (???). This section focuses on tmap and emphasizes the important aesthetic and layout options. tmap is a powerful and flexible map-making package with sensible defaults. It has a concise syntax that allows for the creation of attractive maps with minimal code which will be familiar to ggplot2 users. It also has the unique capability to generate static and interactive maps using the same code via tmap_mode(). Finally, it accepts a wider range of spatial classes (including raster objects) than alternatives such as ggplot2 (see the vignettes tmap-getstarted and tmap-changes-v2, as well as (???), for further documentation). 6.8.1 tmap basics Like ggplot2, tmap is based on the idea of a ‘grammar of graphics’ (???). This involves a separation between the input data and the aesthetics (how data are visualised): each input dataset can be ‘mapped’ in a range of different ways including location on the map (defined by data’s geometry), color, and other visual variables. The basic building block is tm_shape() (which defines input data, raster and vector objects), followed by one or more layer elements such as tm_fill() and tm_dots(). This layering is demonstrated in the chunk below, which generates the maps presented in Figure 6.1: # Add fill layer to nz shape tm_shape(nz) + tm_fill() # Add border layer to nz shape tm_shape(nz) + tm_borders() # Add fill and border layers to nz shape tm_shape(nz) + tm_fill() + tm_borders() Figure 6.1: New Zealand’s shape plotted with fill (left), border (middle) and fill and border (right) layers added using tmap functions. The object passed to tm_shape() in this case is nz, an sf object representing the regions of New Zealand (see Section ?? for more on sf objects). Layers are added to represent nz visually, with tm_fill() and tm_borders() creating shaded areas (left panel) and border outlines (middle panel) in Figure 6.1, respectively. This is an intuitive approach to map making: the common task of adding new layers is undertaken by the addition operator +, followed by tm_*(). The asterisk (*) refers to a wide range of layer types which have self-explanatory names including fill, borders (demonstrated above), bubbles, text and raster (see help(\"tmap-element\") for a full list). This layering is illustrated in the right panel of Figure 6.1, the result of adding a border on top of the fill layer. qtm() is a handy function to create quick thematic maps (hence the snappy name). It is concise and provides a good default visualization in many cases: qtm(nz), for example, is equivalent to tm_shape(nz) + tm_fill() + tm_borders(). Further, layers can be added concisely using multiple qtm() calls, such as qtm(nz) + qtm(nz_height). The disadvantage is that it makes aesthetics of individual layers harder to control, explaining why we avoid teaching it in this chapter. 6.8.2 Map objects A useful feature of tmap is its ability to store objects representing maps. The code chunk below demonstrates this by saving the last plot in Figure 6.1 as an object of class tmap (note the use of tm_polygons() which condenses tm_fill() + tm_borders() into a single function): map_nz = tm_shape(nz) + tm_polygons() class(map_nz) ## [1] &quot;tmap&quot; map_nz can be plotted later, for example by adding additional layers (as shown below) or simply running map_nz in the console, which is equivalent to print(map_nz). New shapes can be added with + tm_shape(new_obj). In this case new_obj represents a new spatial object to be plotted on top of preceding layers. When a new shape is added in this way, all subsequent aesthetic functions refer to it, until another new shape is added. This syntax allows the creation of maps with multiple shapes and layers, as illustrated in the next code chunk which uses the function tm_raster() to plot a raster layer (with alpha set to make the layer semi-transparent): # map_nz1 = map_nz + # tm_shape(nz_elev) + tm_raster(alpha = 0.7) Building on the previously created map_nz object, the preceding code creates a new map object map_nz1 that contains another shape (nz_elev) representing average elevation across New Zealand (see Figure ??, left). More shapes and layers can be added, as illustrated in the code chunk below which creates nz_water, representing New Zealand’s territorial waters, and adds the resulting lines to an existing map object. nz_water = st_union(nz) %&gt;% st_buffer(22200) %&gt;% st_cast(to = &quot;LINESTRING&quot;) # map_nz2 = map_nz1 + # tm_shape(nz_water) + tm_lines() There is no limit to the number of layers or shapes that can be added to tmap objects. The same shape can even be used multiple times. The final map illustrated in Figure ?? is created by adding a layer representing high points (stored in the object nz_height) onto the previously created map_nz2 object with tm_dots() (see ?tm_dots and ?tm_bubbles for details on tmap’s point plotting functions). The resulting map, which has four layers, is illustrated in the right-hand panel of Figure ??: # map_nz3 = map_nz2 + # tm_shape(nz_height) + tm_dots() A useful and little known feature of tmap is that multiple map objects can be arranged in a single ‘metaplot’ with tmap_arrange(). This is demonstrated in the code chunk below which plots map_nz1 to map_nz3, resulting in Figure ??. # tmap_arrange(map_nz1, map_nz2, map_nz3) More elements can also be added with the + operator. Aesthetic settings, however, are controlled by arguments to layer functions. 6.8.3 Aesthetics The plots in the previous section demonstrate tmap’s default aesthetic settings. Gray shades are used for tm_fill() and tm_bubbles() layers and a continuous black line is used to represent lines created with tm_lines(). Of course, these default values and other aesthetics can be overridden. The purpose of this section is to show how. There are two main types of map aesthetics: those that change with the data and those that are constant. Unlike ggplot2, which uses the helper function aes() to represent variable aesthetics, tmap accepts aesthetic arguments that are either variable fields (based on column names) or constant values.1 The most commonly used aesthetics for fill and border layers include color, transparency, line width and line type, set with col, alpha, lwd, and lty arguments, respectively. The impact of setting these with fixed values is illustrated in Figure 6.2. ma1 = tm_shape(nz) + tm_fill(col = &quot;red&quot;) ma2 = tm_shape(nz) + tm_fill(col = &quot;red&quot;, alpha = 0.3) ma3 = tm_shape(nz) + tm_borders(col = &quot;blue&quot;) ma4 = tm_shape(nz) + tm_borders(lwd = 3) ma5 = tm_shape(nz) + tm_borders(lty = 2) ma6 = tm_shape(nz) + tm_fill(col = &quot;red&quot;, alpha = 0.3) + tm_borders(col = &quot;blue&quot;, lwd = 3, lty = 2) tmap_arrange(ma1, ma2, ma3, ma4, ma5, ma6) Figure 6.2: The impact of changing commonly used fill and border aesthetics to fixed values. Like base R plots, arguments defining aesthetics can also receive values that vary. Unlike the base R code below (which generates the left panel in Figure 6.3), tmap aesthetic arguments will not accept a numeric vector: plot(st_geometry(nz), col = nz$Land_area) # works tm_shape(nz) + tm_fill(col = nz$Land_area) # fails #&gt; Error: Fill argument neither colors nor valid variable name(s) Instead col (and other aesthetics that can vary such as lwd for line layers and size for point layers) requires a character string naming an attribute associated with the geometry to be plotted. Thus, one would achieve the desired result as follows (plotted in the right-hand panel of Figure 6.3): tm_shape(nz) + tm_fill(col = &quot;Land_area&quot;) Figure 6.3: Comparison of base (left) and tmap (right) handling of a numeric color field. An important argument in functions defining aesthetic layers such as tm_fill() is title, which sets the title of the associated legend. The following code chunk demonstrates this functionality by providing a more attractive name than the variable name Land_area (note the use of expression() to create superscript text): legend_title = expression(&quot;Area (km&quot;^2*&quot;)&quot;) map_nza = tm_shape(nz) + tm_fill(col = &quot;Land_area&quot;, title = legend_title) + tm_borders() 6.8.4 Color settings Color settings are an important part of map design. They can have a major impact on how spatial variability is portrayed as illustrated in Figure 6.4. This shows four ways of coloring regions in New Zealand depending on median income, from left to right (and demonstrated in the code chunk below): The default setting uses ‘pretty’ breaks, described in the next paragraph. breaks allows you to manually set the breaks. n sets the number of bins into which numeric variables are categorized. palette defines the color scheme, for example BuGn. tm_shape(nz) + tm_polygons(col = &quot;Median_income&quot;) breaks = c(0, 3, 4, 5) * 10000 tm_shape(nz) + tm_polygons(col = &quot;Median_income&quot;, breaks = breaks) tm_shape(nz) + tm_polygons(col = &quot;Median_income&quot;, n = 10) tm_shape(nz) + tm_polygons(col = &quot;Median_income&quot;, palette = &quot;BuGn&quot;) Figure 6.4: Illustration of settings that affect color settings. The results show (from left to right): default settings, manual breaks, n breaks, and the impact of changing the palette. Another way to change color settings is by altering color break (or bin) settings. In addition to manually setting breaks tmap allows users to specify algorithms to automatically create breaks with the style argument. Here are six of the most useful break styles: style = pretty, the default setting, rounds breaks into whole numbers where possible and spaces them evenly; style = equal divides input values into bins of equal range and is appropriate for variables with a uniform distribution (not recommended for variables with a skewed distribution as the resulting map may end-up having little color diversity); style = quantile ensures the same number of observations fall into each category (with the potential downside that bin ranges can vary widely); style = jenks identifies groups of similar values in the data and maximizes the differences between categories; style = cont (and order) present a large number of colors over continuous color fields and are particularly suited for continuous rasters (order can help visualize skewed distributions); style = cat was designed to represent categorical values and assures that each category receives a unique color. Figure 6.5: Illustration of different binning methods set using the style argument in tmap. Although style is an argument of tmap functions, in fact it originates as an argument in classInt::classIntervals() — see the help page of this function for details. Palettes define the color ranges associated with the bins and determined by the breaks, n, and style arguments described above. The default color palette is specified in tm_layout() (see Section 6.8.5 to learn more); however, it could be quickly changed using the palette argument. It expects a vector of colors or a new color palette name, which can be selected interactively with tmaptools::palette_explorer(). You can add a - as prefix to reverse the palette order. There are three main groups of color palettes: categorical, sequential and diverging (Figure 6.6), and each of them serves a different purpose. Categorical palettes consist of easily distinguishable colors and are most appropriate for categorical data without any particular order such as state names or land cover classes. Colors should be intuitive: rivers should be blue, for example, and pastures green. Avoid too many categories: maps with large legends and many colors can be uninterpretable.2 The second group is sequential palettes. These follow a gradient, for example from light to dark colors (light colors tend to represent lower values), and are appropriate for continuous (numeric) variables. Sequential palettes can be single (Blues go from light to dark blue, for example) or multi-color/hue (YlOrBr is gradient from light yellow to brown via orange, for example), as demonstrated in the code chunk below — output not shown, run the code yourself to see the results! tm_shape(nz) + tm_polygons(&quot;Population&quot;, palette = &quot;Blues&quot;) tm_shape(nz) + tm_polygons(&quot;Population&quot;, palette = &quot;YlOrBr&quot;) The last group, diverging palettes, typically range between three distinct colors (purple-white-green in Figure 6.6) and are usually created by joining two single-color sequential palettes with the darker colors at each end. Their main purpose is to visualize the difference from an important reference point, e.g., a certain temperature, the median household income or the mean probability for a drought event. The reference point’s value can be adjusted in tmap using the midpoint argument. Figure 6.6: Examples of categorical, sequential and diverging palettes. There are two important principles for consideration when working with colors: perceptibility and accessibility. Firstly, colors on maps should match our perception. This means that certain colors are viewed through our experience and also cultural lenses. For example, green colors usually represent vegetation or lowlands and blue is connected with water or cool. Color palettes should also be easy to understand to effectively convey information. It should be clear which values are lower and which are higher, and colors should change gradually. This property is not preserved in the rainbow color palette; therefore, we suggest avoiding it in geographic data visualization (???). Instead, the viridis color palettes, also available in tmap, can be used. Secondly, changes in colors should be accessible to the largest number of people. Therefore, it is important to use colorblind friendly palettes as often as possible.3 6.8.5 Layouts The map layout refers to the combination of all map elements into a cohesive map. Map elements include among others the objects to be mapped, the title, the scale bar, margins and aspect ratios, while the color settings covered in the previous section relate to the palette and break-points used to affect how the map looks. Both may result in subtle changes that can have an equally large impact on the impression left by your maps. Additional elements such as north arrows and scale bars have their own functions: tm_compass() and tm_scale_bar() (Figure 6.7). map_nz + tm_compass(type = &quot;8star&quot;, position = c(&quot;left&quot;, &quot;top&quot;)) + tm_scale_bar(breaks = c(0, 100, 200), text.size = 1) Figure 6.7: Map with additional elements - a north arrow and scale bar. tmap also allows a wide variety of layout settings to be changed, some of which, produced using the following code (see args(tm_layout) or ?tm_layout for a full list), are illustrated in Figure 6.8: map_nz + tm_layout(title = &quot;New Zealand&quot;) map_nz + tm_layout(scale = 5) map_nz + tm_layout(bg.color = &quot;lightblue&quot;) map_nz + tm_layout(frame = FALSE) Figure 6.8: Layout options specified by (from left to right) title, scale, bg.color and frame arguments. The other arguments in tm_layout() provide control over many more aspects of the map in relation to the canvas on which it is placed. Here are some useful layout settings (some of which are illustrated in Figure 6.9): Frame width (frame.lwd) and an option to allow double lines (frame.double.line). Margin settings including outer.margin and inner.margin. Font settings controlled by fontface and fontfamily. Legend settings including binary options such as legend.show (whether or not to show the legend) legend.only (omit the map) and legend.outside (should the legend go outside the map?), as well as multiple choice settings such as legend.position. Default colors of aesthetic layers (aes.color), map attributes such as the frame (attr.color). Color settings controlling sepia.intensity (how yellowy the map looks) and saturation (a color-grayscale). Figure 6.9: Illustration of selected layout options. The impact of changing the color settings listed above is illustrated in Figure 6.10 (see ?tm_layout for a full list). Figure 6.10: Illustration of selected color-related layout options. Beyond the low-level control over layouts and colors, tmap also offers high-level styles, using the tm_style() function (representing the second meaning of ‘style’ in the package). Some styles such as tm_style(\"cobalt\") result in stylized maps, while others such as tm_style(\"gray\") make more subtle changes, as illustrated in Figure 6.11, created using the code below (see 08-tmstyles.R): map_nza + tm_style(&quot;bw&quot;) map_nza + tm_style(&quot;classic&quot;) map_nza + tm_style(&quot;cobalt&quot;) map_nza + tm_style(&quot;col_blind&quot;) Figure 6.11: Selected tmap styles. A preview of predefined styles can be generated by executing tmap_style_catalogue(). This creates a folder called tmap_style_previews containing nine images. Each image, from tm_style_albatross.png to tm_style_white.png, shows a faceted map of the world in the corresponding style. Note: tmap_style_catalogue() takes some time to run. 6.8.6 Faceted maps Faceted maps, also referred to as ‘small multiples’, are composed of many maps arranged side-by-side, and sometimes stacked vertically (???). Facets enable the visualization of how spatial relationships change with respect to another variable, such as time. The changing populations of settlements, for example, can be represented in a faceted map with each panel representing the population at a particular moment in time. The time dimension could be represented via another aesthetic such as color. However, this risks cluttering the map because it will involve multiple overlapping points (cities do not tend to move over time!). Typically all individual facets in a faceted map contain the same geometry data repeated multiple times, once for each column in the attribute data (this is the default plotting method for sf objects, see Chapter ??). However, facets can also represent shifting geometries such as the evolution of a point pattern over time. This use case of faceted plot is illustrated in Figure 6.12. urb_1970_2030 = urban_agglomerations %&gt;% filter(year %in% c(1970, 1990, 2010, 2030)) tm_shape(world) + tm_polygons() + tm_shape(urb_1970_2030) + tm_symbols(col = &quot;black&quot;, border.col = &quot;white&quot;, size = &quot;population_millions&quot;) + tm_facets(by = &quot;year&quot;, nrow = 2, free.coords = FALSE) Figure 6.12: Faceted map showing the top 30 largest urban agglomerations from 1970 to 2030 based on population projections by the United Nations. The preceding code chunk demonstrates key features of faceted maps created with tmap: Shapes that do not have a facet variable are repeated (the countries in world in this case). The by argument which varies depending on a variable (year in this case). The nrow/ncol setting specifying the number of rows and columns that facets should be arranged into. The free.coords parameter specifying if each map has its own bounding box. In addition to their utility for showing changing spatial relationships, faceted maps are also useful as the foundation for animated maps (see Section 6.9). 6.8.7 Inset maps An inset map is a smaller map rendered within or next to the main map. It could serve many different purposes, including providing a context (Figure 6.13) or bringing some non-contiguous regions closer to ease their comparison (Figure 6.14). They could be also used to focus on a smaller area in more detail or to cover the same area as the map, but representing a different topic. In the example below, we create a map of the central part of New Zealand’s Southern Alps. Our inset map will show where the main map is in relation to the whole New Zealand. The first step is to define the area of interest, which can be done by creating a new spatial object, nz_region. nz_region = st_bbox(c(xmin = 1340000, xmax = 1450000, ymin = 5130000, ymax = 5210000), crs = st_crs(nz_height)) %&gt;% st_as_sfc() In the second step, we create a base map showing the New Zealand’s Southern Alps area. This is a place where the most important message is stated. nz_height_map = tm_shape(nz_elev, bbox = nz_region) + tm_raster(style = &quot;cont&quot;, palette = &quot;YlGn&quot;, legend.show = TRUE) + tm_shape(nz_height) + tm_symbols(shape = 2, col = &quot;red&quot;, size = 1) + tm_scale_bar(position = c(&quot;left&quot;, &quot;bottom&quot;)) The third step consists of the inset map creation. It gives a context and helps to locate the area of interest. Importantly, this map needs to clearly indicate the location of the main map, for example by stating its borders. nz_map = tm_shape(nz) + tm_polygons() + tm_shape(nz_height) + tm_symbols(shape = 2, col = &quot;red&quot;, size = 0.1) + tm_shape(nz_region) + tm_borders(lwd = 3) Finally, we combine the two maps using the function viewport() from the grid package, the first arguments of which specify the center location (x and y) and a size (width and height) of the inset map. library(grid) nz_height_map print(nz_map, vp = viewport(0.8, 0.27, width = 0.5, height = 0.5)) Figure 6.13: Inset map providing a context - location of the central part of the Southern Alps in New Zealand. Inset map can be saved to file either by using a graphic device (see Section ??) or the tmap_save() function and its arguments - insets_tm and insets_vp. Inset maps are also used to create one map of non-contiguous areas. Probably, the most often used example is a map of the United States, which consists of the contiguous United States, Hawaii and Alaska. It is very important to find the best projection for each individual inset in these types of cases (see Chapter ?? to learn more). We can use US National Atlas Equal Area for the map of the contiguous United States by putting its EPSG code in the projection argument of tm_shape(). us_states_map = tm_shape(us_states, projection = 2163) + tm_polygons() + tm_layout(frame = FALSE) The rest of our objects, hawaii and alaska, already have proper projections; therefore, we just need to create two separate maps: hawaii_map = tm_shape(hawaii) + tm_polygons() + tm_layout(title = &quot;Hawaii&quot;, frame = FALSE, bg.color = NA, title.position = c(&quot;LEFT&quot;, &quot;BOTTOM&quot;)) alaska_map = tm_shape(alaska) + tm_polygons() + tm_layout(title = &quot;Alaska&quot;, frame = FALSE, bg.color = NA) The final map is created by combining and arranging these three maps: us_states_map print(hawaii_map, vp = grid::viewport(0.35, 0.1, width = 0.2, height = 0.1)) print(alaska_map, vp = grid::viewport(0.15, 0.15, width = 0.3, height = 0.3)) Figure 6.14: Map of the United States. The code presented above is compact and can be used as the basis for other inset maps but the results, in Figure 6.14, provide a poor representation of the locations of Hawaii and Alaska. For a more in-depth approach, see the us-map vignette from the geocompkg. 6.9 Animated maps Faceted maps, described in Section 6.8.6, can show how spatial distributions of variables change (e.g., over time), but the approach has disadvantages. Facets become tiny when there are many of them. Furthermore, the fact that each facet is physically separated on the screen or page means that subtle differences between facets can be hard to detect. Animated maps solve these issues. Although they depend on digital publication, this is becoming less of an issue as more and more content moves online. Animated maps can still enhance paper reports: you can always link readers to a web-page containing an animated (or interactive) version of a printed map to help make it come alive. There are several ways to generate animations in R, including with animation packages such as gganimate, which builds on ggplot2 (see Section 6.12). This section focusses on creating animated maps with tmap because its syntax will be familiar from previous sections and the flexibility of the approach. Figure 6.15 is a simple example of an animated map. Unlike the faceted plot, it does not squeeze multiple maps into a single screen and allows the reader to see how the spatial distribution of the world’s most populous agglomerations evolve over time (see the book’s website for the animated version). Figure 6.15: Animated map showing the top 30 largest urban agglomerations from 1950 to 2030 based on population projects by the United Nations. Animated version available online at: geocompr.robinlovelace.net. The animated map illustrated in Figure 6.15 can be created using the same tmap techniques that generate faceted maps, demonstrated in Section 6.8.6. There are two differences, however, related to arguments in tm_facets(): along = \"year\" is used instead of by = \"year\". free.coords = FALSE, which maintains the map extent for each map iteration. These additional arguments are demonstrated in the subsequent code chunk: urb_anim = tm_shape(world) + tm_polygons() + tm_shape(urban_agglomerations) + tm_dots(size = &quot;population_millions&quot;) + tm_facets(along = &quot;year&quot;, free.coords = FALSE) The resulting urb_anim represents a set of separate maps for each year. The final stage is to combine them and save the result as a .gif file with tmap_animation(). The following command creates the animation illustrated in Figure 6.15, with a few elements missing, that we will add in during the exercises: tmap_animation(urb_anim, filename = &quot;urb_anim.gif&quot;, delay = 25) Another illustration of the power of animated maps is provided in Figure 6.16. This shows the development of states in the United States, which first formed in the east and then incrementally to the west and finally into the interior. Code to reproduce this map can be found in the script 08-usboundaries.R. Figure 6.16: Animated map showing population growth, state formation and boundary changes in the United States, 1790-2010. Animated version available online at geocompr.robinlovelace.net. 6.10 Interactive maps While static and animated maps can enliven geographic datasets, interactive maps can take them to a new level. Interactivity can take many forms, the most common and useful of which is the ability to pan around and zoom into any part of a geographic dataset overlaid on a ‘web map’ to show context. Less advanced interactivity levels include popups which appear when you click on different features, a kind of interactive label. More advanced levels of interactivity include the ability to tilt and rotate maps, as demonstrated in the mapdeck example below, and the provision of “dynamically linked” sub-plots which automatically update when the user pans and zooms (???). The most important type of interactivity, however, is the display of geographic data on interactive or ‘slippy’ web maps. The release of the leaflet package in 2015 revolutionized interactive web map creation from within R and a number of packages have built on these foundations adding new features (e.g., leaflet.extras) and making the creation of web maps as simple as creating static maps (e.g., mapview and tmap). This section illustrates each approach in the opposite order. We will explore how to make slippy maps with tmap (the syntax of which we have already learned), mapview and finally leaflet (which provides low-level control over interactive maps). A unique feature of tmap mentioned in Section 4.0.1 is its ability to create static and interactive maps using the same code. Maps can be viewed interactively at any point by switching to view mode, using the command tmap_mode(\"view\"). This is demonstrated in the code below, which creates an interactive map of New Zealand based on the tmap object map_nz, created in Section 6.8.2, and illustrated in Figure 6.17: tmap_mode(&quot;view&quot;) map_nz Figure 6.17: Interactive map of New Zealand created with tmap in view mode. Interactive version available online at: geocompr.robinlovelace.net. Now that the interactive mode has been ‘turned on’, all maps produced with tmap will launch (another way to create interactive maps is with the tmap_leaflet function). Notable features of this interactive mode include the ability to specify the basemap with tm_basemap() (or tmap_options()) as demonstrated below (result not shown): map_nz + tm_basemap(server = &quot;OpenTopoMap&quot;) An impressive and little-known feature of tmap’s view mode is that it also works with faceted plots. The argument sync in tm_facets() can be used in this case to produce multiple maps with synchronized zoom and pan settings, as illustrated in Figure 6.18, which was produced by the following code: world_coffee = left_join(world, coffee_data, by = &quot;name_long&quot;) facets = c(&quot;coffee_production_2016&quot;, &quot;coffee_production_2017&quot;) tm_shape(world_coffee) + tm_polygons(facets) + tm_facets(nrow = 1, sync = TRUE) Figure 6.18: Faceted interactive maps of global coffee production in 2016 and 2017 in sync, demonstrating tmap’s view mode in action. Switch tmap back to plotting mode with the same function: tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting If you are not proficient with tmap, the quickest way to create interactive maps may be with mapview. The following ‘one liner’ is a reliable way to interactively explore a wide range of geographic data formats: mapview::mapview(nz) Figure 6.19: Illustration of mapview in action. mapview has a concise syntax yet is powerful. By default, it provides some standard GIS functionality such as mouse position information, attribute queries (via pop-ups), scale bar, and zoom-to-layer buttons. It offers advanced controls including the ability to ‘burst’ datasets into multiple layers and the addition of multiple layers with + followed by the name of a geographic object. Additionally, it provides automatic coloring of attributes (via argument zcol). In essence, it can be considered a data-driven leaflet API (see below for more information about leaflet). Given that mapview always expects a spatial object (sf, Spatial*, Raster*) as its first argument, it works well at the end of piped expressions. Consider the following example where sf is used to intersect lines and polygons and then is visualised with mapview (Figure 6.20). trails %&gt;% st_transform(st_crs(franconia)) %&gt;% st_intersection(franconia[franconia$district == &quot;Oberfranken&quot;, ]) %&gt;% st_collection_extract(&quot;LINE&quot;) %&gt;% mapview(color = &quot;red&quot;, lwd = 3, layer.name = &quot;trails&quot;) + mapview(franconia, zcol = &quot;district&quot;, burst = TRUE) + breweries Figure 6.20: Using mapview at the end of a sf-based pipe expression. One important thing to keep in mind is that mapview layers are added via the + operator (similar to ggplot2 or tmap). This is a frequent gotcha in piped workflows where the main binding operator is %&gt;%. For further information on mapview, see the package’s website at: r-spatial.github.io/mapview/. There are other ways to create interactive maps with R. The googleway package, for example, provides an interactive mapping interface that is flexible and extensible (see the googleway-vignette for details). Another approach by the same author is mapdeck, which provides access to Uber’s Deck.gl framework. Its use of WebGL enables it to interactively visualize large datasets (up to millions of points). The package uses Mapbox access tokens, which you must register for before using the package. Note that the following block assumes the access token is stored in your R environment as MAPBOX=your_unique_key. This can be added with edit_r_environ() from the usethis package. A unique feature of mapdeck is its provision of interactive ‘2.5d’ perspectives, illustrated in Figure 6.21. This means you can can pan, zoom and rotate around the maps, and view the data ‘extruded’ from the map. Figure 6.21, generated by the following code chunk, visualizes road traffic crashes in the UK, with bar height respresenting casualties per area. library(mapdeck) set_token(Sys.getenv(&quot;MAPBOX&quot;)) crash_data = read.csv(&quot;https://git.io/geocompr-mapdeck&quot;) crash_data = na.omit(crash_data) ms = mapdeck_style(&quot;dark&quot;) mapdeck(style = ms, pitch = 45, location = c(0, 52), zoom = 4) %&gt;% add_grid(data = crash_data, lat = &quot;lat&quot;, lon = &quot;lng&quot;, cell_size = 1000, elevation_scale = 50, layer_id = &quot;grid_layer&quot;, colour_range = viridisLite::plasma(6)) Figure 6.21: Map generated by mapdeck, representing road traffic casualties across the UK. Height of 1 km cells represents number of crashes. In the browser you can zoom and drag, in addition to rotating and tilting the map when pressing Cmd/Ctrl. Multiple layers can be added with the %&gt;% operator, as demonstrated in the mapdeck vignette. Mapdeck also supports sf objects, as can be seen by replacing the add_grid() function call in the preceding code chunk with add_polygon(data = lnd, layer_id = \"polygon_layer\"), to add polygons representing London to an interactive tilted map. Last but not least is leaflet which is the most mature and widely used interactive mapping package in R. leaflet provides a relatively low-level interface to the Leaflet JavaScript library and many of its arguments can be understood by reading the documentation of the original JavaScript library (see leafletjs.com). Leaflet maps are created with leaflet(), the result of which is a leaflet map object which can be piped to other leaflet functions. This allows multiple map layers and control settings to be added interactively, as demonstrated in the code below which generates Figure 6.22 (see rstudio.github.io/leaflet/ for details). pal = colorNumeric(&quot;RdYlBu&quot;, domain = cycle_hire$nbikes) leaflet(data = cycle_hire) %&gt;% addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %&gt;% addCircles(col = ~pal(nbikes), opacity = 0.9) %&gt;% addPolygons(data = lnd, fill = FALSE) %&gt;% addLegend(pal = pal, values = ~nbikes) %&gt;% setView(lng = -0.1, 51.5, zoom = 12) %&gt;% addMiniMap() Figure 6.22: The leaflet package in action, showing cycle hire points in London. 6.11 Mapping applications The interactive web maps demonstrated in Section 6.10 can go far. Careful selection of layers to display, base-maps and pop-ups can be used to communicate the main results of many projects involving geocomputation. But the web mapping approach to interactivity has limitations: Although the map is interactive in terms of panning, zooming and clicking, the code is static, meaning the user interface is fixed. All map content is generally static in a web map, meaning that web maps cannot scale to handle large datasets easily. Additional layers of interactivity, such a graphs showing relationships between variables and ‘dashboards’ are difficult to create using the web-mapping approach. Overcoming these limitations involves going beyond static web mapping and towards geospatial frameworks and map servers. Products in this field include GeoDjango (which extends the Django web framework and is written in Python), MapGuide (a framework for developing web applications, largely written in C++) and GeoServer (a mature and powerful map server written in Java). Each of these (particularly GeoServer) is scalable, enabling maps to be served to thousands of people daily — assuming there is sufficient public interest in your maps! The bad news is that such server-side solutions require much skilled developer time to set-up and maintain, often involving teams of people with roles such as a dedicated geospatial database administrator (DBA). The good news is that web mapping applications can now be rapidly created using shiny, a package for converting R code into interactive web applications. This is thanks to its support for interactive maps via functions such as renderLeaflet(), documented on the Shiny integration section of RStudio’s leaflet website. This section gives some context, teaches the basics of shiny from a web mapping perspective and culminates in a full-screen mapping application in less than 100 lines of code. The way shiny works is well documented at shiny.rstudio.com. The two key elements of a shiny app reflect the duality common to most web application development: ‘front end’ (the bit the user sees) and ‘back end’ code. In shiny apps, these elements are typically created in objects named ui and server within an R script named app.R, which lives in an ‘app folder’. This allows web mapping applications to be represented in a single file, such as the coffeeApp/app.R file in the book’s GitHub repo. In shiny apps these are often split into ui.R (short for user interface) and server.R files, naming conventions used by shiny-server, a server-side Linux application for serving shiny apps on public-facing websites. shiny-server also serves apps defined by a single app.R file in an ‘app folder’. Learn more at: https://github.com/rstudio/shiny-server. Before considering large apps, it is worth seeing a minimal example, named ‘lifeApp’, in action.4 The code below defines and launches — with the command shinyApp() — a lifeApp, which provides an interactive slider allowing users to make countries appear with progressively lower levels of life expectancy (see Figure 6.23): library(shiny) # for shiny apps library(leaflet) # renderLeaflet function library(spData) # loads the world dataset ui = fluidPage( sliderInput(inputId = &quot;life&quot;, &quot;Life expectancy&quot;, 49, 84, value = 80), leafletOutput(outputId = &quot;map&quot;) ) server = function(input, output) { output$map = renderLeaflet({ leaflet() %&gt;% addProviderTiles(&quot;OpenStreetMap.BlackAndWhite&quot;) %&gt;% addPolygons(data = world[world$lifeExp &lt; input$life, ])}) } shinyApp(ui, server) Figure 6.23: Screenshot showing minimal example of a web mapping application created with shiny. The user interface (ui) of lifeApp is created by fluidPage(). This contains input and output ‘widgets’ — in this case, a sliderInput() (many other *Input() functions are available) and a leafletOutput(). These are arranged row-wise by default, explaining why the slider interface is placed directly above the map in Figure 6.23 (see ?column for adding content column-wise). The server side (server) is a function with input and output arguments. output is a list of objects containing elements generated by render*() function — renderLeaflet() which in this example generates output$map. Input elements such as input$life referred to in the server must relate to elements that exist in the ui — defined by inputId = \"life\" in the code above. The function shinyApp() combines both the ui and server elements and serves the results interactively via a new R process. When you move the slider in the map shown in Figure 6.23, you are actually causing R code to re-run, although this is hidden from view in the user interface. Building on this basic example and knowing where to find help (see ?shiny), the best way forward now may be to stop reading and start programming! The recommended next step is to open the previously mentioned coffeeApp/app.R script in an IDE of choice, modify it and re-run it repeatedly. The example contains some of the components of a web mapping application implemented in shiny and should ‘shine’ a light on how they behave. The coffeeApp/app.R script contains shiny functions that go beyond those demonstrated in the simple ‘lifeApp’ example. These include reactive() and observe() (for creating outputs that respond to the user interface — see ?reactive) and leafletProxy() (for modifying a leaflet object that has already been created). Such elements are critical to the creation of web mapping applications implemented in shiny. A range of ‘events’ can be programmed including advanced functionality such as drawing new layers or subsetting data, as described in the shiny section of RStudio’s leaflet website. There are a number of ways to run a shiny app. For RStudio users, the simplest way is probably to click on the ‘Run App’ button located in the top right of the source pane when an app.R, ui.R or server.R script is open. shiny apps can also be initiated by using runApp() with the first argument being the folder containing the app code and data: runApp(\"coffeeApp\") in this case (which assumes a folder named coffeeApp containing the app.R script is in your working directory). You can also launch apps from a Unix command line with the command Rscript -e 'shiny::runApp(\"coffeeApp\")'. Experimenting with apps such as coffeeApp will build not only your knowledge of web mapping applications in R, but also your practical skills. Changing the contents of setView(), for example, will change the starting bounding box that the user sees when the app is initiated. Such experimentation should not be done at random, but with reference to relevant documentation, starting with ?shiny, and motivated by a desire to solve problems such as those posed in the exercises. shiny used in this way can make prototyping mapping applications faster and more accessible than ever before (deploying shiny apps is a separate topic beyond the scope of this chapter). Even if your applications are eventually deployed using different technologies, shiny undoubtedly allows web mapping applications to be developed in relatively few lines of code (60 in the case of coffeeApp). That does not stop shiny apps getting rather large. The Propensity to Cycle Tool (PCT) hosted at pct.bike, for example, is a national mapping tool funded by the UK’s Department for Transport. The PCT is used by dozens of people each day and has multiple interactive elements based on more than 1000 lines of code (???). While such apps undoubtedly take time and effort to develop, shiny provides a framework for reproducible prototyping that should aid the development process. One potential problem with the ease of developing prototypes with shiny is the temptation to start programming too early, before the purpose of the mapping application has been envisioned in detail. For that reason, despite advocating shiny, we recommend starting with the longer established technology of a pen and paper as the first stage for interactive mapping projects. This way your prototype web applications should be limited not by technical considerations, but by your motivations and imagination. Figure 6.24: coffeeApp, a simple web mapping application for exploring global coffee production in 2016 and 2017. Interactive version available online at geocompr.robinlovelace.net. 6.12 Other mapping packages tmap provides a powerful interface for creating a wide range of static maps (Section 4.0.1) and also supports interactive maps (Section 6.10). But there are many other options for creating maps in R. The aim of this section is to provide a taster of some of these and pointers for additional resources: map making is a surprisingly active area of R package development, so there is more to learn than can be covered here. The most mature option is to use plot() methods provided by core spatial packages sf and raster, covered in Sections ?? and ??, respectively. What we have not mentioned in those sections was that plot methods for raster and vector objects can be combined when the results draw onto the same plot area (elements such as keys in sf plots and multi-band rasters will interfere with this). This behavior is illustrated in the subsequent code chunk which generates Figure 6.25. plot() has many other options which can be explored by following links in the ?plot help page and the sf vignette sf5. g = st_graticule(nz, lon = c(170, 175), lat = c(-45, -40, -35)) plot(nz_water, graticule = g, axes = TRUE, col = &quot;blue&quot;) raster::plot(nz_elev / 1000, add = TRUE) plot(st_geometry(nz), add = TRUE) Figure 6.25: Map of New Zealand created with plot(). The legend to the right refers to elevation (1000 m above sea level). Since version 2.3.0, the tidyverse plotting package ggplot2 has supported sf objects with geom_sf(). The syntax is similar to that used by tmap: an initial ggplot() call is followed by one or more layers, that are added with + geom_*(), where * represents a layer type such as geom_sf() (for sf objects) or geom_points() (for points). ggplot2 plots graticules by default. The default settings for the graticules can be overridden using scale_x_continuous(), scale_y_continuous() or coord_sf(datum = NA). Other notable features include the use of unquoted variable names encapsulated in aes() to indicate which aesthetics vary and switching data sources using the data argument, as demonstrated in the code chunk below which creates Figure 6.26: library(ggplot2) g1 = ggplot() + geom_sf(data = nz, aes(fill = Median_income)) + geom_sf(data = nz_height) + scale_x_continuous(breaks = c(170, 175)) g1 Figure 6.26: Map of New Zealand created with ggplot2. An advantage of ggplot2 is that it has a strong user-community and many add-on packages. Good additional resources can be found in the open source ggplot2 book (???) and in the descriptions of the multitude of ‘ggpackages’ such as ggrepel and tidygraph. Another benefit of maps based on ggplot2 is that they can easily be given a level of interactivity when printed using the function ggplotly() from the plotly package. Try plotly::ggplotly(g1), for example, and compare the result with other plotly mapping functions described at: blog.cpsievert.me. At the same time, ggplot2 has a few drawbacks. The geom_sf() function is not always able to create a desired legend to use from the spatial data. Raster objects are also not natively supported in ggplot2 and need to be converted into a data frame before plotting. We have covered mapping with sf, raster and ggplot2 packages first because these packages are highly flexible, allowing for the creation of a wide range of static maps. Before we cover mapping packages for plotting a specific type of map (in the next paragraph), it is worth considering alternatives to the packages already covered for general-purpose mapping (Table 6.1). Table 6.1: Selected general-purpose mapping packages. Package Title cartography Thematic Cartography ggplot2 Create Elegant Data Visualisations Using the Grammar of Graphics googleway Accesses Google Maps APIs to Retrieve Data and Plot Maps ggspatial Spatial Data Framework for ggplot2 leaflet Create Interactive Web Maps with Leaflet mapview Interactive Viewing of Spatial Data in R plotly Create Interactive Web Graphics via ‘plotly.js’ rasterVis Visualization Methods for Raster Data tmap Thematic Maps Table 6.1 shows a range of mapping packages are available, and there are many others not listed in this table. Of note is cartography, which generates a range of unusual maps including choropleth, ‘proportional symbol’ and ‘flow’ maps, each of which is documented in the vignette cartography. Several packages focus on specific map types, as illustrated in Table 6.2. Such packages create cartograms that distort geographical space, create line maps, transform polygons into regular or hexagonal grids, and visualize complex data on grids representing geographic topologies. Table 6.2: Selected specific-purpose mapping packages, with associated metrics. Package Title cartogram Create Cartograms with R geogrid Turn Geospatial Polygons into Regular or Hexagonal Grids geofacet ‘ggplot2’ Faceting Utilities for Geographical Data globe Plot 2D and 3D Views of the Earth, Including Major Coastline linemap Line Maps All of the aforementioned packages, however, have different approaches for data preparation and map creation. In the next paragraph, we focus solely on the cartogram package. Therefore, we suggest to read the linemap, geogrid and geofacet documentations to learn more about them. A cartogram is a map in which the geometry is proportionately distorted to represent a mapping variable. Creation of this type of map is possible in R with cartogram, which allows for creating continuous and non-contiguous area cartograms. It is not a mapping package per se, but it allows for construction of distorted spatial objects that could be plotted using any generic mapping package. The cartogram_cont() function creates continuous area cartograms. It accepts an sf object and name of the variable (column) as inputs. Additionally, it is possible to modify the intermax argument - maximum number of iterations for the cartogram transformation. For example, we could represent median income in New Zeleand’s regions as a continuous cartogram (the right-hand panel of Figure 6.27) as follows: library(cartogram) nz_carto = cartogram_cont(nz, &quot;Median_income&quot;, itermax = 5) tm_shape(nz_carto) + tm_polygons(&quot;Median_income&quot;) Figure 6.27: Comparison of standard map (left) and continuous area cartogram (right). cartogram also offers creation of non-contiguous area cartograms using cartogram_ncont() and Dorling cartograms using cartogram_dorling(). Non-contiguous area cartograms are created by scaling down each region based on the provided weighting variable. Dorling cartograms consist of circles with their area proportional to the weighting variable. The code chunk below demonstrates creation of non-contiguous area and Dorling cartograms of US states’ population (Figure 6.28): us_states2163 = st_transform(us_states, 2163) us_states2163_ncont = cartogram_ncont(us_states2163, &quot;total_pop_15&quot;) us_states2163_dorling = cartogram_dorling(us_states2163, &quot;total_pop_15&quot;) Figure 6.28: Comparison of non-continuous area cartogram (left) and Dorling cartogram (right). New mapping packages are emerging all the time. In 2018 alone, a number of mapping packages have been released on CRAN, including mapdeck, mapsapi, and rayshader. In terms of interactive mapping, leaflet.extras contains many functions for extending the functionality of leaflet (see the end of the point-pattern vignette in the geocompkg website for examples of heatmaps created by leaflet.extras). 6.13 Exercises These exercises rely on a new object, africa. Create it using the world and worldbank_df datasets from the spData package as follows (see Chapter ??): africa = world %&gt;% filter(continent == &quot;Africa&quot;, !is.na(iso_a2)) %&gt;% left_join(worldbank_df, by = &quot;iso_a2&quot;) %&gt;% dplyr::select(name, subregion, gdpPercap, HDI, pop_growth) %&gt;% st_transform(&quot;+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25&quot;) We will also use zion and nlcd datasets from spDataLarge: zion = st_read((system.file(&quot;vector/zion.gpkg&quot;, package = &quot;spDataLarge&quot;))) data(nlcd, package = &quot;spDataLarge&quot;) Create a map showing the geographic distribution of the Human Development Index (HDI) across Africa with base graphics (hint: use plot()) and tmap packages (hint: use tm_shape(africa) + ...). Name two advantages of each based on the experience. Name three other mapping packages and an advantage of each. Bonus: create three more maps of Africa using these three packages. Extend the tmap created for the previous exercise so the legend has three bins: “High” (HDI above 0.7), “Medium” (HDI between 0.55 and 0.7) and “Low” (HDI below 0.55). Bonus: improve the map aesthetics, for example by changing the legend title, class labels and color palette. Represent africa’s subregions on the map. Change the default color palette and legend title. Next, combine this map and the map created in the previous exercise into a single plot. Create a land cover map of the Zion National Park. Change the default colors to match your perception of the land cover categories Add a scale bar and north arrow and change the position of both to improve the map’s aesthetic appeal Bonus: Add an inset map of Zion National Park’s location in the context of the Utah state. (Hint: an object representing Utah can be subset from the us_states dataset.) Create facet maps of countries in Eastern Africa: With one facet showing HDI and the other representing population growth (hint: using variables HDI and pop_growth, respectively) With a ‘small multiple’ per country Building on the previous facet map examples, create animated maps of East Africa: Showing first the spatial distribution of HDI scores then population growth Showing each country in order Create an interactive map of Africa: With tmap With mapview With leaflet Bonus: For each approach, add a legend (if not automatically provided) and a scale bar Sketch on paper ideas for a web mapping app that could be used to make transport or land-use policies more evidence based: In the city you live, for a couple of users per day In the country you live, for dozens of users per day Worldwide for hundreds of users per day and large data serving requirements Update the code in coffeeApp/app.R so that instead of centering on Brazil the user can select which country to focus on: Using textInput() Using selectInput() Reproduce Figure 6.1 and the 1st and 6th panel of Figure 6.5 as closely as possible using the ggplot2 package. Join us_states and us_states_df together and calculate a poverty rate for each state using the new dataset. Next, construct a continuous area cartogram based on total population. Finally, create and compare two maps of the poverty rate: (1) a standard choropleth map and (2) a map using the created cartogram boundaries. What is the information provided by the first and the second map? How do they differ from each other? Visualize population growth in Africa. Next, compare it with the maps of a hexagonal and regular grid created using the geogrid package. 6.14 My Notes Using and applying GIS techniques in R has become much easier since the additional functionality of Java-script libraries. One of these libraries in the leaflet library for mapping. Below are some examples of these mapping tools with examples. I like the idea of know what to do in arcGIS so that it is easy to work with researchers that use either R or arcGIS. For a GIS map there are two main options. Here are the resources for building interactive and static maps in R using a range of different packages: ’leaflet` 6.15 A single location on a map Here is the birthplace of R plotted with leaflet, addTiles and the addMarkers… 6.16 Leaflet plots still coming 6.17 My Notes I have sent the following to Matt to input into arcGIS and compare rendered maps. # grid.locations &lt;- # label add hand drawn image here 6.17.1 Extracting mymaps data This is for security reasons. library(leaflet) library(leaflet.extras) Tab Name 1 Tab Name 2 If there is a clash between a fixed value and a column name, the column name takes precedence. This can be verified by running the next code chunk after running nz$red = 1:nrow(nz).↩ col = \"MAP_COLORS\" can be used in maps with a large number of individual polygons (for example, a map of individual countries) to create unique colors for adjacent polygons.↩ See the “Color blindness simulator” options in tmaptools::palette_explorer().↩ The word ‘app’ in this context refers to ‘web application’ and should not be confused with smartphone apps, the more common meaning of the word.↩ "],
["tabs.html", " 7 Leaflet tabs", " 7 Leaflet tabs ## Tests {.tabset} Still working on this… Would be nice if something like this would work. And the headings and tabs function is not working. (For coding reasons not yet known by me but should be basic) "]
]
